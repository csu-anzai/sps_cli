#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""

Realiza processamento de arquivos nos formatos CSV, JSON ou TXT.
Algumas funções foram concebidas para processarem arquivos de relatórios dos sistemas SAE e SIGRA da UnB.

Usage:
    unb-tools unir lista-estudantes <pasta-alvo> <nome_arquivo_saida>
    unb-tools (unir | intersectar) arquivos (csv | json) <arquivo1> <arquivo2> <nome_da_coluna>
    unb-tools integrar-estudos-antigos
    unb-tools lista-estudos-antigos
    unb-tools lista-de-historicos-para-estudos-antigos
    unb-tools processar-estudo-antigo <arquivo1>
    unb-tools processar-estudos-antigos [<pasta-alvo>]
    unb-tools processar-curriculo-sigra <arquivo1>
    unb-tools processar-curriculos-sigra [<pasta-alvo>]
    unb-tools processar-historico-gr <arquivo1>
    unb-tools processar-historicos-gr [<pasta-alvo>]
    unb-tools preecher-lacunas (csv | json) <arquivo1> <colunas-de-visualizacao>...
    unb-tools selecionar-linhas (apagar | copiar | mover) <arquivo1> <nome_da_coluna> <valor-alvo>
    unb-tools ( join-alu-rel ) <target-folder> <output-txt-fname>
    unb-tools ( integrate_old_sae_etd )
    unb-tools ( create_curric_metainfo_index )
    unb-tools ( old_sae_extract_list )
    unb-tools ( old_sae_extract_hist_list )
    unb-tools ( process_sae_etd ) <target-sae-txt-file>
    unb-tools ( multiprocess_sae_etd )
    unb-tools ( fix-csv-alu-rel ) <csv-file> [ <csv-delimiter> ]
    unb-tools ( curric-process ) <target-curric-txt-file>
    unb-tools ( multi-curric-process ) <target-curric-folder>
    unb-tools ( sigra-hist-process ) <target-sigra-hist-txt-file>
    unb-tools ( multi-sigra-hist-process ) <target-multi-hist-zipfile>
    unb-tools ( join-union ) ( csv | json ) <file1> <file2> <joint-col>
    unb-tools ( join-intersection )  ( csv | json ) <file1> <file2> <joint-col>
    unb-tools ( cross-values ) ( csv | json ) <file>
    unb-tools ( fill-gaps) ( csv | json ) <file> <ref-cols>
    unb-tools ( remove-lines ) <file1> <coluna> <valor-de-conferencia>
    unb-tools ( calculate ) (csv|json) <file1>
    unb-tools ( create_new_value ) ( csv | json ) <file1> <col>...
    unb-tools ( create_new_value-from_script ) ( csv | json ) <script_file>


Options:
    --version

Observações:

"""


import getpass
import os

from docopt import docopt
from subprocess import getoutput
from python_modules.py_functions_data_manager import render_form_get_values
from python_modules.cli_unb_tools import \
    join_alurel,\
    old_sae_etd_rename_files,\
    old_sae_etd_strip_chars,\
    old_sae_etd_movefiles_to_folder,\
    old_sae_extract_list,\
    old_sae_extract_hist_list,\
    process_sae_etd,\
    fix_joined_alurel,\
    process_curric,\
    multi_process_curric,\
    multiprocess_sae_etd,\
    process_sigra_hist,\
    multi_process_sigra_academic_history,\
    cruzar_variaveis,\
    create_curric_metainfo_index

from python_modules.py_functions_csv import remove_lines, obter_frq_abs_e_rel, write_csv, read_csv

from python_modules.py_euristic_tools import create_new_value_col_from_script

from python_modules.cli_tools import select_op, select_ops
from python_modules.py_functions_json import save_json, load_json
from python_modules.py_functions_csv import make_complete_stat_from_csv, join_csv_intersection, join_csv_union, create_new_csv_value_col_from_old#, create_new_csv_value_col_from_cross_old

args = docopt(__doc__)


def create_new_value_col_from_cross_old(dict_array, list_of_old_cols, interactive=True, script_descriptor=None):
    num_of_cols = len(list_of_old_cols)

    if (interactive == False) and (script_descriptor == None):
        if type(script_descriptor) != dict:
            print("Descritor não apresentado ou em formato inadequado...")
            exit()

    if num_of_cols == 1:

        old_col1 = list_of_old_cols[0]
        old_col1_values = []
        for line in dict_array:
            if not line[old_col1] in old_col1_values:
                old_col1_values.append(line[old_col1])
        old_col1_values.sort()

        if interactive == True:
            print("Selecione os valores que deverão ser checados para disparar o gatilho de registro:")
            selected = select_ops(old_col1_values, 2)
            print("Defina o nome da nova coluna:")
            print("Cuidado! Se o nome definido for igual a un nome anteriormente existente, as informações anteriores dessa coluna serão sobrescritas:\n")
            new_col_name = input("$: ")
            print("Defina o valor que deverá ser registrado na nova coluna quando os valores selecionados forem encontrados: \n")
            new_value = input("$: ")
        else:
            selected = script_descriptor['valores_de_checagem'][list_of_old_cols[0]]
            new_col_name = script_descriptor['nome_da_nova_coluna']
            new_value = script_descriptor['valor_se_checagem_verdadeira']

        for line in dict_array:
            if line.get(new_col_name) == None:
                line[new_col_name] = ""
            if line[old_col1] in selected:
                line[new_col_name] = new_value

    elif num_of_cols == 2:

        old_col1 = list_of_old_cols[0]
        old_col2 = list_of_old_cols[1]
        old_col1_values = []
        old_col2_values = []

        for line in dict_array:
            if not line[old_col1] in old_col1_values:
                old_col1_values.append(line[old_col1])
            if not line[old_col2] in old_col2_values:
                old_col2_values.append(line[old_col2])

        old_col1_values.sort()
        old_col2_values.sort()

        if interactive == True:
            print("Selecione os valores que deverão ser checados para disparar o gatilho de registro na coluna {}:".format(list_of_old_cols[0]))
            selected_itens_col1 = select_ops(old_col1_values, 2)
            print("Selecione os valores que deverão ser checados para disparar o gatilho de registro na coluna {}:".format(list_of_old_cols[1]))
            selected_itens_col2 = select_ops(old_col2_values, 2)

            print("Defina o nome da nova coluna:")
            print("Cuidado! Se o nome definido for igual a un nome anteriormente existente, as informações anteriores dessa coluna serão sobrescritas:\n")
            new_col_name = input("$: ")

            print("Defina o valor que deverá ser registrado na nova coluna quando os valores selecionados forem encontrados: \n")
            new_value = input("$: ")
        else:
            selected_itens_col1 = script_descriptor['valores_de_checagem'][list_of_old_cols[0]]
            selected_itens_col2 = script_descriptor['valores_de_checagem'][list_of_old_cols[1]]
            new_col_name = script_descriptor['nome_da_nova_coluna']
            new_value = script_descriptor['valor_se_checagem_verdadeira']

        for line in dict_array:
            if line.get(new_col_name) == None:
                line[new_col_name] = ""
            if (line[old_col1] in selected_itens_col1) and (line[old_col2] in selected_itens_col2):
                line[new_col_name] = new_value

    elif num_of_cols == 3:
        old_col1 = list_of_old_cols[0]
        old_col2 = list_of_old_cols[1]
        old_col3 = list_of_old_cols[2]
        old_col1_values = []
        old_col2_values = []
        old_col3_values = []

        if interactive == True:

            for line in dict_array:
                if not line[old_col1] in old_col1_values:
                    old_col1_values.append(line[old_col1])
                if not line[old_col2] in old_col2_values:
                    old_col2_values.append(line[old_col2])
                if not line[old_col3] in old_col3_values:
                    old_col3_values.append(line[old_col3])				

            old_col1_values.sort()
            old_col2_values.sort()
            old_col3_values.sort()

            print("Selecione os valores que deverão ser checados para disparar o gatilho de registro na coluna {}:".format(old_col1))
            selected_itens_col1 = select_ops(old_col1_values, 2)
            print("Selecione os valores que deverão ser checados para disparar o gatilho de registro na coluna {}:".format(old_col2))
            selected_itens_col2 = select_ops(old_col2_values, 2)
            print("Selecione os valores que deverão ser checados para disparar o gatilho de registro na coluna {}:".format(old_col3))
            selected_itens_col3 = select_ops(old_col3_values, 2)

            print("Defina o nome da nova coluna:")
            print("Cuidado! Se o nome definido for igual a un nome anteriormente existente, as informações anteriores dessa coluna serão sobrescritas:\n")
            new_col_name = input("$: ")

            print("Defina o valor que deverá ser registrado na nova coluna quando os valores selecionados forem encontrados: \n")
            new_value = input("$: ")
        else:
            selected_itens_col1 = script_descriptor['valores_de_checagem'][list_of_old_cols[0]]
            selected_itens_col2 = script_descriptor['valores_de_checagem'][list_of_old_cols[1]]
            selected_itens_col3 = script_descriptor['valores_de_checagem'][list_of_old_cols[2]]

            new_col_name = script_descriptor['nome_da_nova_coluna']
            new_value = script_descriptor['valor_se_checagem_verdadeira']

        count = 0
        work = ""
        for line in dict_array:
            count += 1

            if line.get(new_col_name) == None:
                line[new_col_name] = ""
            #if (line[old_col1] == selected_itens_col1) and (line[old_col2] == selected_itens_col2) and (line[old_col3] == selected_itens_col3):
            #if line[old_col1] in selected_itens_col1:
                #if line[old_col2] in selected_itens_col2:
                    #if line[old_col3] in selected_itens_col3:
            if selected_itens_col1.find(line[old_col1]) != -1:
                if selected_itens_col2.find(line[old_col2]) != -1:
                    if selected_itens_col3.find(line[old_col3]) != -1:
                        print("Encontrada correspondência na linha: {} » {} ".format(count, line["NOME_ESTUDANTE"]))
                        print("  ·", old_col1, "»» {} in {}".format(line[old_col1], selected_itens_col1))
                        print("  ·", old_col2, "»» {} in {}".format(line[old_col2], selected_itens_col2))
                        print("  ·", old_col3, "»» {} in {}".format(line[old_col3], selected_itens_col3))	
                        print("")
                        if line["NOME_ESTUDANTE"] == "Rodrigo Ramos de Lima":
                            input()

                        line[new_col_name] = new_value
            else:
                work += "Sem correspondência na linha: {} » {}\n".format(count, line["NOME_ESTUDANTE"])
                work += str("  · "+ old_col1+ " »» {} in {} ".format(line[old_col1], selected_itens_col1) + '\n')
                work += str("  · "+ old_col2+ " »» {} in {} ".format(line[old_col2], selected_itens_col2) + '\n')
                work += str("  · "+ old_col3+ " »» {} in {} ".format(line[old_col3], selected_itens_col3) + '\n\n')
        
        f=open('work','w')
        f.write(work)
        f.close()
        write_csv(dict_array, "SAIDA.csv")

        return dict_array

    elif num_of_cols == 4:

        old_col1 = list_of_old_cols[0]
        old_col2 = list_of_old_cols[1]
        old_col3 = list_of_old_cols[2]
        old_col4 = list_of_old_cols[4]
        old_col1_values = []
        old_col2_values = []
        old_col3_values = []
        old_col4_values = []

        for line in dict_array:
            if not line[old_col1] in old_col1_values:
                old_col1_values.append(line[old_col1])
            if not line[old_col2] in old_col2_values:
                old_col2_values.append(line[old_col2])
            if not line[old_col3] in old_col3_values:
                old_col3_values.append(line[old_col3])
            if not line[old_col4] in old_col4_values:
                old_col4_values.append(line[old_col4])								

        old_col1_values.sort()
        old_col2_values.sort()
        old_col3_values.sort()
        old_col4_values.sort()

        if interactive == True:
            print("Selecione os valores que deverão ser checados para disparar o gatilho de registro na coluna {}:".format(old_col1))
            selected_itens_col1 = select_ops(old_col1_values, 2)
            print("Selecione os valores que deverão ser checados para disparar o gatilho de registro na coluna {}:".format(old_col2))
            selected_itens_col2 = select_ops(old_col2_values, 2)
            print("Selecione os valores que deverão ser checados para disparar o gatilho de registro na coluna {}:".format(old_col3))
            selected_itens_col3 = select_ops(old_col3_values, 2)
            print("Selecione os valores que deverão ser checados para disparar o gatilho de registro na coluna {}:".format(old_col4))
            selected_itens_col4 = select_ops(old_col4_values, 2)		

            print("Defina o nome da nova coluna:")
            print("Cuidado! Se o nome definido for igual a un nome anteriormente existente, as informações anteriores dessa coluna serão sobrescritas:\n")
            new_col_name = input("$: ")

            print("Defina o valor que deverá ser registrado na nova coluna quando os valores selecionados forem encontrados: \n")
            new_value = input("$: ")
        else:
            selected_itens_col1 = script_descriptor['valores_de_checagem'][list_of_old_cols[0]]
            selected_itens_col2 = script_descriptor['valores_de_checagem'][list_of_old_cols[1]]
            selected_itens_col3 = script_descriptor['valores_de_checagem'][list_of_old_cols[2]]
            selected_itens_col4 = script_descriptor['valores_de_checagem'][list_of_old_cols[3]]			
            new_col_name = script_descriptor['nome_da_nova_coluna']
            new_value = script_descriptor['valor_se_checagem_verdadeira']

        for line in dict_array:
            if line.get(new_col_name) == None:
                line[new_col_name] = ""
            if (line[old_col1] in selected_itens_col1) and (line[old_col2] in selected_itens_col2) and (line[old_col3] in selected_itens_col3) and (line[old_col4] in selected_itens_col4):
                line[new_col_name] = new_value
    return dict_array


def main():
    if args['join-alu-rel']:
        join_alurel(args['<target-folder>'], args['<output-txt-fname>'])

    elif args['integrate_old_sae_etd']:
        old_sae_etd_rename_files()
        old_sae_etd_movefiles_to_folder()
        old_sae_etd_strip_chars()

    elif args['create_curric_metainfo_index']: 
        create_curric_metainfo_index()

    elif args['old_sae_extract_list']: 
        old_sae_extract_list()

    elif args['old_sae_extract_hist_list']: 
        old_sae_extract_hist_list()

    elif args['process_sae_etd']:
        process_sae_etd(args['<target-sae-txt-file>'])

    elif args['multiprocess_sae_etd']:
        multiprocess_sae_etd()

    elif args['fix-csv-alu-rel']:
        fix_joined_alurel(args['<csv-file>'], args['<csv-delimiter>'])
 
    elif args['curric-process']:
        process_curric(args['<target-curric-txt-file>'])
 
    elif args['multi-curric-process']:
        multi_process_curric(args['<target-curric-folder>'])
 
    elif args['sigra-hist-process']:
        process_sigra_hist(args['<target-sigra-hist-txt-file>'])
 
    elif args['multi-sigra-hist-process']:
        multi_process_sigra_academic_history(args['<target-multi-hist-zipfile>'])
 
    elif args['join-union']:
        if args['csv']:
            join_csv_union(args['<file1>'], args['<file2>'], args['<joint-col>'])
        elif args['json']:
            print("Não implementado...")

    elif args['join-intersection']:
        if args['csv']:
            join_csv_intersection(args['<file1>'], args['<file2>'], args['<joint-col>'])
        elif args['json']:
            print("Não implementado...")
    
    elif args['remove-lines']:
        remove_lines(args['<file1>'], args['<coluna>'], args['<valor-de-conferencia>'])
 
    elif args['calculate']:
        if args['csv']:
            obter_frq_abs_e_rel(args['<file1>'])
        elif args['json']:
            print("Não implementado...")

    elif args['cross-values']:
        if args['csv']:
            cruzar_variaveis(args["<file>"])
        elif args['json']:
            print("Não implementado...")
 
    elif args['create_new_value']:
        if args['csv']:
            pass
            #create_new_csv_value_col_from_cross_old(args["<file1>"], args['<col>'])
        elif args['json']:
            print("Não implementado...")

    elif args['create_new_value-from_script']:
        script_instructions = load_json("./"+args["<script_file>"])

        input_file = script_instructions['arquivo_alvo']
        output_file = script_instructions['arquivo_saida']
        input_filetype = input_file.split('.')[-1].lower()
        output_filetype = output_file.split('.')[-1].lower()
        tasks = script_instructions['analises']

        if input_filetype == 'csv':
            input_file_info = read_csv(input_file)
            
        elif input_filetype == 'json':
            input_file_info = load_json(input_file)

        
        for task in tasks:
            colunas_selecionadas = []
            for c in task['valores_de_checagem'].keys():
                colunas_selecionadas.append(c)

        create_new_value_col_from_cross_old(input_file_info, colunas_selecionadas, interactive=False, script_descriptor=task)

        modified_info = create_new_value_col_from_script(script_instructions, input_file_info)

        if output_filetype == 'csv':
            write_csv(modified_info, output_file)
            
        elif output_filetype == 'json':
            save_json(modified_info, output_file)

        
if __name__ == '__main__':
    main()